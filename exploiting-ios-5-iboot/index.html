<!DOCTYPE html>
<html lang="en-US">
<head>

<link rel="icon" href="../apple-touch-icon.png">
<link rel="stylesheet" type="text/css" href="../new-common/general.css">

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1"> 

<title>Exploiting the iOS 5 iBoot bug</title>

</head>

<body>

<img class="cover" src="resources/cover.png" srcset="resources/cover.png 2x">

<div class="main">
<div class="text">

<h1>Exploiting the iOS 5 iBoot bug</h1>
<div class="desc">Created on 5.11.18</div>

<div class="p"><b>Important note:</b> this is the very first bug I’ve ever exploited and, therefore, my first write-up of such kind. If you notice a mistake of any kind, <i>polite</i> criticism is always appreciated
</div>

<div class="p">
<h2>The bug</h2>
This bug was discovered and exploited by <b>@p0sixninja</b> many years ago. It’s settled in HFS+ driver and was fixed in iOS 6. It is triggered by setting <b>hfs_header->catalogFile.extents[1].blockCount</b> to a high value (e.g. <b>0x10000000</b>).
This makes iBoot try to read a huge chunk of data from HFS+ partition to heap (near the end of it):

<p class="cli">
HFSInitPartition: 0x4ff57e00<br>
HFSReadBlock: offset 0x400 size 0x200 buffer 0x4ff30efc<br>
returned: 0x200<br>
HFSReadBlock: offset 0x100a000 size 0x100 buffer 0x4ff310fc<br>
returned: 0x100<br>
HFSReadBlock: offset 0x80a000 size 0x100 buffer 0x4ff311fc<br>
returned: 0x100<br>
HFSReadBlock: offset 0x1214000 size 0x2000 buffer 0x4ffaf180<br>
returned: 0x2000<br>
HFSReadBlock: offset 0x28e000 size 0xffd92000 buffer 0x4ffaf180
</p>
</div>

<div class="p">
<h2>The exploit</h2>
iBoot memory is mirrored after every <b>0x40000000</b> bytes (1 GB) on devices with 1 GB RAM, every <b>0x20000000</b> (512 MB) on devices with 512 MB RAM and every <b>0x10000000</b> (256 MB) on devices with 256 MB RAM, don’t know about the others. That means, for example, if iBoot is based at <b>0x4FF00000</b> (like in case of <b>S5L8920</b>-<b>S5L8922</b>), we can also read/write to it at <b>0x5FF00000</b>:

<p class="cli">
[l] lina md 0x5ff00000 0x20<br>
0x5ff00000: 0e0000ea 18f09fe5  18f09fe5 18f09fe5<br>
0x5ff00010: 18f09fe5 18f09fe5  18f09fe5 18f09fe5
</p>

The general idea of our exploit is based on this fact — make iBoot overwrite itself with data from a partition, which we fully control. Target IRQ handler address to get arbitrary code execution

</div>

<div class="p">
<h2>The exploitation</h2>

<div class="p">
<b>Note</b>: this guide comes with the <a href="resources/starter_kit.zip">free exploitation starter kit</a>, which will help you much on this way. It contains parts of HFS+ for initial bug triggering and a source code for payloads
</div>

<div class="p">
We will use <b>n18ap</b> on iOS 5.1.1 in most of examples in this article 
</div>

<div class="p">
Let’s start with simply triggering the bug. This is pretty easy:

<ul>
<li>Create a third partition, we don’t want to corrupt main root filesystem</li>
<li>Delete from NVRAM anything that you feel isn’t needed (we’ll talk about the reasons behind that later)</li>
<li>Restore iOS 5.1.1 root filesystem for </b>n18ap</b> to the third partition</li>
<li>Replace the value at offset <b>0x52C</b> in restored HFS by a large number (<b>0x10000000</b> should do fine), and a value at <b>0x528</b> by a low number (e.g. <b>0x10</b>). Note that all values in HFS+ header are big-endian</li>
<li>Take a target iBoot, patch its <span class="cli">boot-command</span> to be <span class="cli">upgrade</span></li>
<li>Add <span class="cli">boot-commanb</span> (this is not a typo) variable with <span class="cli">upgrade</span> value to NVRAM</li>
<li>Boot the iBoot</li>
</ul>

</div>

<div class="p">
Shortly after the iBoot tries to mount the filesystem and load iBEC from it, you’ll get a panic:

<p class="cli">
panic: arm_exception_abort: ARM data abort abort in supervisor mode at 0x4ff172b8 due to translation error:<br>
 far 0x50000000 fsr 0x00000805<br>
 r0 0x50000000 0x600000d3 0x00000001 0x4ff69ee0<br>
 r4 0x50001180 0x50000040 0x00000003 0x4ff3716c<br>
 r8 0x4ff172b8 0x00000cfc 0x00000001 0x4ffff180 0x00000000<br>
 sp 0x4ff3715c lr 0x4ff1cd97 spsr 0x000000d3
</p>

</div>

<div class="p">
Yes, UART-cable is highly recommended for this exploiting this bug. It’s still possible to succeed without it, but much harder. I’ll give some advice in the end of the guide
</div>

<div class="p">
Extract from @p0sixninja’s write-up about the panic:<br>

<div class="citation">
<i>
The only logical explanation would be something being overwritten between our heap buffer and 0x60000000 [this is about s5l8930x] is causing it to crash once it gets to 0x60000000. Dumping a lot of memory any analyzing it shows there's really only 2 distinct structure between our heap buffer (it's the last buffer allocated in heap so we're not corrupting any other heap buffers). These 2 structures are the stack (but we already know there was no stack corruption based on our earlier analysis), and a special structure in ARM called TLB (Translation Look-aside Buffer). The TLB is a specialized cache that holds a table of physical addresses which are mapped to virtual addresses in the system memory. In iBEC this structure starts at address 0x5FFF8000. This would make since because reason for the crash from the report states "Domain Error". A little research in the ARM technical reference shows that this happens when an illegal virtual to physical page mapping is attempted to be looked up. The TLB is essentially one 32bit address containing representing each physical to virtual mapping on the system
</i>
</div>
</div>

<div class="p">
How can we avoid corrupting the TLB? Just rewrite it with a copy from the HFS partition. You're probably wondering now — how can we put TLB at random place in HFS? Won't it ruin its' structure? And even if it won’t, how do we know where to put it? These questions share an answer - a wrapper for </b>HFSReadBlock()</b>
</div>

<div class="p">
<h3>The wrapper</h3>
We have to know from where, to where and how many bytes iBoot reads from a partition with a filesystem. For that purpose we’ll create a tiny wrapper for <b>HFSReadBlock()</b>
</div>

<div class="p">
<b>HFSReadBlock()</b> is a very simple function, which just extracts the address of <b>blockdev_read_hook()</b> from the block device descriptor and passes its' own args to it:

<img class="align" src="resources/hfsreadblock_original.png">

</div>

<div class="p">
The function is very easy to locate, it's used to read the HFS+ header in the very beginning of the <b>HFSInitPartition()</b> flow:

<img class="align" src="resources/hfsreadblock_location.png">

</div>

<div class="p">
Our aim is to make a function with the same functionality plus printing args passed to it. Luckily for you, I already wrote one and it’s available in the starter kit
</div>

<div class="p">
Pass your offsets - <b>printf</b> is obviously offset of <b>printf()</b>+1 (because we’re in Thumb) and <b>BASEADDR</b> is where the payload is going to be located
</div>

<div class="p">
Good place to land it is around build banner’s strings. Put a branch (not with link! This is very important) to our wrapper payload right at the top of <b>HFSReadBlock()</b>, so the payload will be executed every time:

<img class="align" src="resources/hfsreadblock_patched.png">

</div>

<div class="p">
Apply patches and boot the iBoot. Now on serial you’ll see this:

<p class="cli">
HFSInitPartition: 0x4ff57e00<br>
HFSReadBlock: offset 0x400 size 0x200 buffer 0x4ff30efc<br>
returned: 0x200<br>
HFSReadBlock: offset 0x100a000 size 0x100 buffer 0x4ff310fc<br>
returned: 0x100<br>
HFSReadBlock: offset 0x80a000 size 0x100 buffer 0x4ff311fc<br>
returned: 0x100<br>
HFSReadBlock: offset 0x1214000 size 0x2000 buffer 0x4ffaf180<br>
returned: 0x2000<br>
HFSReadBlock: offset 0x28e000 size 0xffd92000 buffer 0x4ffaf180<br>
panic: arm_exception_abort: ARM data abort abort in supervisor mode at 0x4ff172b8 due to translation error:<br>
 far 0x50000000 fsr 0x00000805<br>
 r0 0x50000000 0x600000d3 0x00000001 0x4ff69ee0<br>
 r4 0x50001180 0x50000040 0x00000003 0x4ff3716c<br>
 r8 0x4ff172b8 0x00000cfc 0x00000001 0x4ffff180 0x00000000<br>
 sp 0x4ff3715c lr 0x4ff1cd97 spsr 0x000000d3
</p>

For now we’re only interested in the last call:

<p class="cli">
HFSReadBlock: offset 0x28e000 size 0xffd92000 buffer 0x4ffaf180
</p>

</div>

<div class="p">
Now you know the precise location of a buffer iBoot tries to read the filesystem to
</div>

<div class="p">
<h3>The TLB</h3>
Dump the stock TLB. Its location is always iBoot base address plus 0xF8000, so it’s 0x4FFF8000 in my case. 0x4000 (16 KB) of size. Once you've dumped it, calculate where it should be within the filesystem:
</div>

<div class="p">
<i><b>0x4FFF8000 - 0x4FFAF180 = 0x48E80</b></i> between heap address and TLB<br>
<i><b>0x48E80 + 0x28E000 = 0x2D6E80</b></i> exact position in our HFS+ partition<br>
</i>
</div>

<div class="p">
An address you’ll get most likely won’t be divided by block size without a remainder. And all operations with disk nodes on pre-PPN devices must be blocksize-aligned. Calculate on which block it has to be and with what padding on both sides:
</div>

<div class="p">
<i><b>0x2D6E80 / 0x2000 = 0x16B (360)</b></i> block<br>
<i><b>0x2D6E80 - 0x16B * 0x2000 = 0xE80</b></i> padding on top<br>
</i>
</div>

<div class="p">
Wrap it in a block with calculated paddings consisted of zeroes and write to the filesystem 
</div>

<p class="cli">
dd if=/block_363 of=/dev/rdisk0s1s3 bs=8192 seek=363
</p>

<div class="p">
Boot the iBoot. Panic should no longer happen:

<p class="cli">
HFSInitPartition: 0x4ff57e00<br>
HFSReadBlock: offset 0x400 size 0x200 buffer 0x4ff30efc<br>
returned: 0x200<br>
HFSReadBlock: offset 0x100a000 size 0x100 buffer 0x4ff310fc<br>
returned: 0x100<br>
HFSReadBlock: offset 0x80a000 size 0x100 buffer 0x4ff311fc<br>
returned: 0x100<br>
HFSReadBlock: offset 0x1214000 size 0x2000 buffer 0x4ffaf180<br>
returned: 0x2000<br>
HFSReadBlock: offset 0x28e000 size 0xffd92000 buffer 0x4ffaf180
</p>

</div>

<div class="p">
But now it just hangs
</div>

<div class="p">
<h3>The hang</h3>
Now, nothing interrupts it from reading. At some point you might get weird distortions on your device’s display. This means it reached framebuffer and overwrote it with data from the filesystem
</div>

<div class="p">
Obviously, we don’t want to wait until it reads enough data to hit mirrored iBoot. There must be a way to speed up this process
</div>

<div class="p">
<h3>The accelerator</h3>
When create new partition, <b>LwVM</b> (or something else?) marks all its blocks as empty. (Partition isn’t a filesystem!) The real reason for this may differ, but the fact is that iBoot skips all zero marked blocks and reads only those that matter
</div>

<div class="p">
Dump all the blocks iBoot reads from the FS, delete the third partition, save, recreate it, write all the blocks back at their original positions plus TLB
</div>

<div class="p">
Boot the iBoot, see how it quickly returns from reading 500+ MB and then starts an infinite loop
</div>

<div class="p">
<h3>The TLB hack</h3>
Let’s take a look at TLB now. Imagine it’s an array of 32-bit integers. At both <b>TLB[0x0]</b> and <b>TLB[iBoot baseaddr/0x100000]</b> you can see the same record. Put it to <b>TLB[mirrored iBoot baseaddr/0x100000]</b>
</div>

<div class="p">
By this we’re kinda directly mapping iBoot physical address (<b>0x4FF00000</b>) to the mirrored iBoot virtual address (<b>0x5FF00000</b>). The real explanation is probably different, but the fact is that it increases success rate of the exploit
</div>

<div class="p">
<h3>The overwritten iBoot</h3>
Calculate where you have to put iBoot image (part of it) in the exploit partition to overwrite it on mirrored address
</div>

<div class="p">
In my case iBoot base is at <b>0x4FF00000</b>, so I need to put part of iBoot image in a place in the partition that <b>blockdev_read_hook()</b> will overwrite memory at <b>0x5FF00000</b> by it:
</div>

<div class="p">
<i><b>0x5FF00000 - 0x4FFAF180 = 0xFF50E80</b></i> between heap address and mirrored iBoot<br>
<i><b>0xFF50E80 + 0x28E000 = 0x101DEE80</b></i> exact position in our HFS+<br>
<i><b>0x101DEE80 / 0x2000 = 0x80EF (33007)</b></i> block<br>
<i><b>0x101DEE80 - 0x80EF * 0x2000 = 0xE80</b></i> padding on top<br>
</i>
</div>

<div class="p">
In the near future our aim will be overwriting IRQ handler vector, for now we’ll touch reset vector instead. Replace <b>0E0000EA</b> with <b>FFFFFFFF</b>. If overwriting will be done fine, a <b>task_yield()</b> panic will be immediately called. That way we’ll know how reliably the mirrored iBoot is overwritten
</div>

<div class="p">
<b>Important:</b> the more bytes of iBoot you overwrite, the more reliable the exploit. It's highly recommended to write about <b>0x16000</b> bytes of iBoot to get 100% success rate
</div>

<div class="p">
Boot the patched iBoot 10 or so times. Every attempt you should get such a panic:

<p class="cli">
panic: task_yield: reset vector overwritten while executing task 'main' (0xffffffff)
</p>

</div>

<div class="p">
<h3>The payload</h3>
If it panics reliably, we can now make it to jump to our payload. The idea is very typical for ARM exploitation - overwrite address of the IRQ vector. In iBoot image for overwriting overwrite value at <b>0x38</b> to a pointer to our payload plus <b>0x1</b>, since our payload is in Thumb (mostly) 
</div>

<div class="p">
The payload calls the real IRQ handler to the handle previous interrupt. Then it restores original address of the IRQ handler, then it prints cool strings and finally jumps to a new fresh iBoot of your choice with whatever patches you would like
</div>

<div class="p">
In the payload replace offsets and compile with <b>GNU ARM Toolchain</b>. <b>JUMPADDR</b> is an address you'll put a new iBoot to jump to. Where to put it in the partition is your choice, I usually use the very first block iBoot reads in the last reading
</div>

<div class="p">
<h3>The new iBoot</h3>
Just take a decrypted unpacked iBoot, apply all necessary patches. Choose a position to put the new iBoot very wisely not to overwrite some other block you write
</div>

<div class="p">
Boot the iBoot. If everything's alright, you'll see something like here:

<p class="cli">
HFSInitPartition: 0x4ff57e00<br>
Hello darkness, my old friend<br>
jumping into image at 0x4ffb0180<br>
image 0x4ff3db00: bdev 0x4ff3ea80 type SCAB offset 0x600<br>
image 0x4ff3db80: bdev 0x4ff3ea80 type ibot offset 0x1200 len 0x2f1f8<br>
image 0x4ff3dc00: bdev 0x4ff3ea80 type dtre offset 0x31200 len 0x9338
</p>

<div class="p">
It should jump to your new bootloader
</div>

<div class="p">
Now reboot to iOS, remove <span class="cli">boot-commanb</span> variable from NVRAM and replace it with <span class="cli">boot-command</span> variable. Reboot
</div>

</div>

</div>

<div class="p">
<h2>The warnings</h2>
This is a heap-based exploit. Be careful with NVRAM variables and partitions. Some additional variables or just one additional partition and heap buffers' addresses will shift, as result the exploit will die 
</div>

<div class="p">
<h2>The recommendations</h2>
Here are the recommendations I promised for those who have no UART-cable: you can try to create a wrapper which will put information about HFS+ readings into NVRAM. Just don't forget to clear it before every next attempt. I personally have never tried such method, since I already have an UART-cable cable. I highly recommend you get one too
</div>

<div class="p">
<h2>The credits</h2>
<ul>
<li><b>@p0sixninja</b> - for discovering the bug and initial idea of the exploit</li>
<li><b>@JonathanSeals</b> - for a lot of wording corrections in this write-up</li>
</ul>
</div>

</div>
</div>

<footer>
Lisa Braun, 2018<br>
<a href="https://twitter.com/nyan_satan"><img class="footer" src="../new-common/twitter.png"></a>
<a href="https://github.com/NyanSatan"><img class="footer" src="../new-common/github.png"></a>
</footer>

</body>

</html>